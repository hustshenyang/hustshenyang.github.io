<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://www.openduino.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="valgrind介绍Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。">
<meta property="og:type" content="article">
<meta property="og:title" content="valgrind使用介绍">
<meta property="og:url" content="http://www.openduino.com/2018/02/06/valgrind%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="yshome">
<meta property="og:description" content="valgrind介绍Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-02-06T14:18:12.000Z">
<meta property="article:modified_time" content="2020-04-10T14:23:19.539Z">
<meta property="article:author" content="ysshen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.openduino.com/2018/02/06/valgrind%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>valgrind使用介绍 | yshome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yshome</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.openduino.com/2018/02/06/valgrind%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ysshen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yshome">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          valgrind使用介绍
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-06 22:18:12" itemprop="dateCreated datePublished" datetime="2018-02-06T22:18:12+08:00">2018-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 22:23:19" itemprop="dateModified" datetime="2020-04-10T22:23:19+08:00">2020-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="valgrind介绍"><a href="#valgrind介绍" class="headerlink" title="valgrind介绍"></a>valgrind介绍</h2><p>Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。</p>
<a id="more"></a>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Valgrind一般包含下列工具： </p>
<h3 id="1-Memcheck"><a href="#1-Memcheck" class="headerlink" title="1. Memcheck"></a>1. Memcheck</h3><p>最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc()/free()/new/delete的调用都会被捕获。所以，它能检测以下问题： <br></p>
<ul>
<li>对未初始化内存的使用；</li>
<li>读/写释放后的内存块； </li>
<li>读/写超出malloc分配的内存块； </li>
<li>读/写不适当的栈中内存块； </li>
<li>内存泄漏，指向一块内存的指针永远丢失； </li>
<li>不正确的malloc/free或new/delete匹配； </li>
<li>memcpy()相关函数中的dst和src指针重叠。 <h3 id="2-Callgrind"><a href="#2-Callgrind" class="headerlink" title="2. Callgrind"></a>2. Callgrind</h3>和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 <h3 id="3-Cachegrind"><a href="#3-Cachegrind" class="headerlink" title="3. Cachegrind"></a>3. Cachegrind</h3>Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 <h3 id="4-Helgrind"><a href="#4-Helgrind" class="headerlink" title="4. Helgrind"></a>4. Helgrind</h3>它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。 <h3 id="5-Massif"><a href="#5-Massif" class="headerlink" title="5. Massif"></a>5. Massif</h3>堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 <br><br>此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表。</li>
<li>Valid-Value 表 <br><br>对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于CPU的每个寄存器，也有一个与之对应的bit向量。这些bits负责记录该字节或者寄存器值是否具有有效的、已初始化的值。<br></li>
<li>Valid-Address 表<br><br>对于进程整个地址空间中的每一个字节(byte)，还有与之对应的1个bit，负责记录该地址是否能够被读写。<br><h4 id="检测原理："><a href="#检测原理：" class="headerlink" title="检测原理："></a>检测原理：<br></h4>当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck则报告读写错误。<br><br>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。<br><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>从<a href="http://www.valgrind.org" target="_blank" rel="noopener">官网</a>下载最新版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvf valgrind-3.11.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> valgrind-3.11.1</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/valgrind--指定安装目录</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-检查内存错误："><a href="#1-检查内存错误：" class="headerlink" title="1. 检查内存错误："></a>1. 检查内存错误：</h3>例如我们原来有一个程序sec_infod，这是一个用gcc –g参数编译的程序，运行它需要：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>
如果我们想用valgrind的内存检测工具，我们就要用如下方法调用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full --show-reachable=yes --trace-children= yes   ./a.out</span><br></pre></td></tr></table></figure>
其中–leak-check=full指的是完全检查内存泄漏，–show-reachable=yes是显示内存泄漏的地点，–trace-children=yes是跟入子进程。<br><br>如果您的程序是会正常退出的程序，那么当程序退出的时候valgrind自然会输出内存泄漏的信息。如果您的程序是个守护进程，那么也不要紧，我们 只要在别的终端下杀死memcheck进程（因为valgrind默认使用memcheck工具，就是默认参数—tools=memcheck）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall memcheck</span><br></pre></td></tr></table></figure>
这样我们的程序（./a.out）就被kill了<br><h3 id="2-检查代码覆盖和性能瓶颈："><a href="#2-检查代码覆盖和性能瓶颈：" class="headerlink" title="2. 检查代码覆盖和性能瓶颈："></a>2. 检查代码覆盖和性能瓶颈：</h3>我们调用valgrind的工具执行程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=callgrind ./sec_infod</span><br></pre></td></tr></table></figure>
会在当前路径下生成callgrind.out.pid（当前生产的是callgrind.out.19689），如果我们想结束程序，可以：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall callgrind</span><br></pre></td></tr></table></figure>
然后我们看一下结果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callgrind_annotate --auto=yes callgrind.out.19689 &gt; <span class="built_in">log</span></span><br><span class="line">vim <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="概要用法："><a href="#概要用法：" class="headerlink" title="概要用法："></a>概要用法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind [[valgrind] [options]] [your-program] [[your-program-options]]</span><br></pre></td></tr></table></figure>
一般像下面这样调用valgrind:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind program args</span><br></pre></td></tr></table></figure>
这样将在Valgrind使用Memcheck运行程序program(带有参数args)。内存检查执行一系列的内存检查功能，包括检测访问未初始化的内存，已经分配内存的错误使用(两次释放，释放后再访问，等等)并检查内存泄漏。<br><br>可用–tool指定使用其它工具：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=toolname program args</span><br></pre></td></tr></table></figure>
可使用的工具如下：<br></li>
<li>cachegrind是一个缓冲模拟器。它可以用来标出你的程序每一行执行的指令数和导致的缓冲不命中数。</li>
<li>callgrind在cachegrind基础上添加调用追踪。它可以用来得到调用的次数以及每次函数调用的开销。作为对cachegrind的补充，callgrind可以分别标注各个线程，以及程序反汇编输出的每条指令的执行次数以及缓存未命中数。</li>
<li>helgrind能够发现程序中潜在的条件竞争。</li>
<li>lackey是一个示例程序，以其为模版可以创建你自己的工具。在程序结束后，它打印出一些基本的关于程序执行统计数据。</li>
<li>massif是一个堆剖析器，它测量你的程序使用了多少堆内存。</li>
<li>memcheck是一个细粒度的的内存检查器。</li>
<li>none没有任何功能。它一般用于Valgrind的调试和基准测试。</li>
</ul>
<table>
<thead>
<tr>
<th>options</th>
<th align="left">常用选项，适用于所有valgrind工具</th>
</tr>
</thead>
<tbody><tr>
<td>-h –help</td>
<td align="left">显示所有选项的帮助，包括内核和选定的工具两者。</td>
</tr>
<tr>
<td>–help-debug</td>
<td align="left">和–help相同，并且还能显示通常只有Valgrind的开发人员使用的调试选项。</td>
</tr>
<tr>
<td>–version</td>
<td align="left">显示Valgrind内核的版本号。工具可以有他们自已的版本号。这是一种保证工具只在它们可以运行的内核上工作的一种设置。这样可以减少在工具和内核之间版本兼容性导致奇怪问题的概率。</td>
</tr>
<tr>
<td>-q –quiet</td>
<td align="left">安静的运行，只打印错误信息。在进行回归测试或者有其它的自动化测试机制时会非常有用。</td>
</tr>
<tr>
<td>-v –verbose</td>
<td align="left">显示详细信息。在各个方面显示你的程序的额外信息，例如：共享对象加载，使用的重置，执行引擎和工具的进程，异常行为的警告信息。重复这个标记可以增加详细的级别。</td>
</tr>
<tr>
<td>-d</td>
<td align="left">调试Valgrind自身发出的信息。通常只有Valgrind开发人员对此感兴趣。重复这个标记可以产生更详细的输出。如果你希望发送一个bug报告，通过-v -v -d -d生成的输出会使你的报告更加有效。</td>
</tr>
<tr>
<td>–tool= [default: memcheck]</td>
<td align="left">运行toolname指定的Valgrind，例如，Memcheck, Addrcheck, Cachegrind,等等。</td>
</tr>
<tr>
<td>–trace-children= [default: no]</td>
<td align="left">当这个选项打开时，Valgrind会跟踪到子进程中。这经常会导致困惑，而且通常不是你所期望的，所以默认这个选项是关闭的。</td>
</tr>
<tr>
<td>–track-fds= [default: no]</td>
<td align="left">当这个选项打开时，Valgrind会在退出时打印一个打开文件描述符的列表。每个文件描述符都会打印出一个文件是在哪里打开的栈回溯，和任何与此文件描述符相关的详细信息比如文件名或socket信息。</td>
</tr>
<tr>
<td>–time-stamp= [default: no]</td>
<td align="left">当这个选项打开时，每条信息之前都有一个从程序开始消逝的时间，用天，小时，分钟，秒和毫秒表示。</td>
</tr>
<tr>
<td>–log-fd= [default: 2, stderr]</td>
<td align="left">指定Valgrind把它所有的消息都输出到一个指定的文件描述符中去。默认值2,　是标准错误输出(stderr)。注意这可能会干扰到客户端自身对stderr的使用, Valgrind的输出与客户程序的输出将穿插在一起输出到stderr。</td>
</tr>
<tr>
<td>–log-file=</td>
<td align="left">指定Valgrind把它所有的信息输出到指定的文件中。实际上，被创建文件的文件名是由filename、’.’和进程号连接起来的（即.），从而每个进程创建不同的文件。</td>
</tr>
<tr>
<td>–log-file-exactly=</td>
<td align="left">类似于–log-file，但是后缀”.pid”不会被添加。如果设置了这个选项，使用Valgrind跟踪多个进程，可能会得到一个乱七八糟的文件。</td>
</tr>
<tr>
<td>–log-file-qualifier=</td>
<td align="left">当和–log-file一起使用时，日志文件名将通过环境变量$VAR来筛选。这对于MPI程序是有益的。更多的细节，查看手册2.3节 “注解”。</td>
</tr>
<tr>
<td>–log-socket=</td>
<td align="left">指定Valgrind输出所有的消息到指定的IP，指定的端口。当使用1500端口时，端口有可能被忽略。如果不能建立一个到指定端口的连接，Valgrind将输出写到标准错误(stderr)。这个选项经常和一个Valgrind监听程序一起使用。更多的细节，查看手册2.3节 “注解”。</td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th>错误相关选项</th>
<th align="left">这些选项适用于所有产生错误的工具，比如Memcheck,　但是Cachegrind不行</th>
</tr>
</thead>
<tbody><tr>
<td>–xml= [default: no]</td>
<td align="left">当这个选项打开时，输出将是XML格式。这是为了使用Valgrind的输出做为输入的工具，例如GUI前端更加容易些。目前这个选项只在Memcheck时生效。</td>
</tr>
<tr>
<td>–xml-user-comment=</td>
<td align="left">在XML开头 附加用户注释，仅在指定了–xml=yes时生效，否则忽略。</td>
</tr>
<tr>
<td>–demangle= [default: yes]</td>
<td align="left">打开/关闭C++的名字自动解码。默认打开。当打开时，Valgrind将尝试着把编码过的C++名字自动转回初始状态。这个解码器可以处理g++版本为2.X,3.X或4.X生成的符号.一个关于名字编码解码重要的事实是，禁止文件中的解码函数名仍然使用他们未解码的形式。Valgrind在搜寻可用的禁止条目时不对函数名解码，因为这将使禁止文件内容依赖于Valgrind的名字解码机制状态， 会使速度变慢，且无意义。</td>
</tr>
<tr>
<td>–num-callers= [default: 12]</td>
<td align="left">默认情况下，Valgrind显示12层函数调用的函数名有助于确定程序的位置。可以通过这个选项来改变这个数字。这样有助在嵌套调用的层次很深时确定程序的位置。注意错误信息通常只回溯到最顶上的4个函数。(当前函数，和它的3个调用者的位置)。所以这并不影响报告的错误总数.这个值的最大值是50。注意高的设置会使Valgrind运行得慢，并且使用更多的内存,但是在嵌套调用层次比较高的程序中非常实用。</td>
</tr>
<tr>
<td>–error-limit= [default: yes]</td>
<td align="left">当这个选项打开时，在总量达到10,000,000，或者1,000个不同的错误，Valgrind停止报告错误。这是为了避免错误跟踪机制在错误很多的程序下变成一个巨大的性能负担。</td>
</tr>
<tr>
<td>–error-exitcode= [default: 0]</td>
<td align="left">指定如果Valgrind在运行过程中报告任何错误时的退出返回值，有两种情况；当设置为默认值(零)时，Valgrind返回的值将是它模拟运行的程序的返回值。当设置为非零值时，如果Valgrind发现任何错误时则返回这个值。在Valgrind做为一个测试工具套件的部分使用时这将非常有用，因为使测试工具套件只检查Valgrind返回值就可以知道哪些测试用例Valgrind报告了错误。</td>
</tr>
<tr>
<td>–show-below-main= [default: no]</td>
<td align="left">默认地，错误时的栈回溯不显示main()之下的任何函数(或者类似的函数像glibc的__libc_start_main()，如果main()没有出现在栈回溯中)；这些大部分都是令人厌倦的C库函数。如果打开这个选项，在main()之下的函数也将会显示。</td>
</tr>
<tr>
<td>–suppressions=<br>[default: $PREFIX/lib/valgrind/default.supp]</td>
<td align="left">指定一个额外的文件读取不需要理会的错误；你可以根据需要使用任意多的额外文件。</td>
</tr>
<tr>
<td>–gen-suppressions= [default: no]</td>
<td align="left">当设置为yes时，Valgrind将会在每个错误显示之后自动暂停并且打印下面这一行: <br><code>---- Print suppression ? --- [Return/N/n/Y/y/C/c] ----</code><br>这个提示的行为和–db-attach选项(见下面)相同。<br>如果选择是，Valgrind会打印出一个错误的禁止条目，你可以把它剪切然后粘帖到一个文件，如果不希望在将来再看到这个错误信息。<br>当设置为all时，Valgrind会对每一个错误打印一条禁止条目，而不向用户询问。<br>这个选项对C++程序非常有用，它打印出编译器调整过的名字。<br>注意打印出来的禁止条目是尽可能的特定的。如果需要把类似的条目归纳起来，比如在函数名中添加通配符。并且，有些时候两个不同的错误也会产生同样的禁止条目，这时Valgrind就会输出禁止条目不止一次，但是在禁止条目的文件中只需要一份拷贝(但是如果多于一份也不会引起什么问题)。并且，禁止条目的名字像&lt;在这儿输入一个禁止条目的名字&gt;;名字并不是很重要，它只是和-v选项一起使用打印出所有使用的禁止条目记录。</td>
</tr>
<tr>
<td>–db-attach= [default: no]</td>
<td align="left">当这个选项打开时，Valgrind将会在每次打印错误时暂停并打出如下一行：<br> <code>---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ----</code> <br>按下回车,或者N、回车，n、回车，Valgrind不会对这个错误启动调试器。<br>按下Y、回车，或者y、回车，Valgrind会启动调试器并设定在程序运行的这个点。当调试结束时，退出，程序会继续运行。在调试器内部尝试继续运行程序，将不会生效。<br>按下C、回车，或者c、回车，Valgrind不会启动一个调试器，并且不会再次询问。<br>注意：–db-attach=yes与–trace-children=yes有冲突。你不能同时使用它们。Valgrind在这种情况下不能启动。</td>
</tr>
<tr>
<td>–db-command= [default: gdb -nw %f %p]</td>
<td align="left">通过–db-attach指定如何使用调试器。默认的调试器是gdb.默认的选项是一个运行时扩展Valgrind的模板。 %f会用可执行文件的文件名替换，%p会被可执行文件的进程ID替换。<br>这指定了Valgrind将怎样调用调试器。默认选项不会因为在构造时是否检测到了GDB而改变,通常是/usr/bin/gdb.使用这个命令，你可以指定一些调用其它的调试器来替换。<br>给出的这个命令字串可以包括一个或多个%p %f扩展。每一个%p实例都被解释成将调试的进程的PID，每一个%f实例都被解释成要调试的进程的可执行文件路径。</td>
</tr>
<tr>
<td>–input-fd= [default: 0, stdin]</td>
<td align="left">使用–db-attach=yes和–gen-suppressions=yes选项，在发现错误时，Valgrind会停下来去读取键盘输入。默认地，从标准输入读取，所以关闭了标准输入的程序会有问题。这个选项允许你指定一个文件描述符来替代标准输入读取。</td>
</tr>
<tr>
<td>–max-stackframe= [default: 2000000]</td>
<td align="left">栈的最大值。如果栈指针的偏移超过这个数量，Valgrind则会认为程序是切换到了另外一个栈执行。<br>如果在程序中有大量的栈分配的数组，你可能需要使用这个选项。</td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>valgrind保持对程序栈指针的追踪。如果栈指针的偏移超过了这个数量，Valgrind假定你的程序切换到了另外一个栈，并且Memcheck行为与栈指针的偏移没有超出这个数量将会不同。通常这种机制运转得很好。然而，如果你的程序在栈上申请了大的结构，这种机制将会表现得愚蠢，并且Memcheck将会报告大量的非法栈内存访问。这个选项允许把这个阀值设置为其它值。<br><br>应该只在Valgrind的调试输出中显示需要这么做时才使用这个选项。在这种情况下，它会告诉你应该指定的新的阀值。<br><br>普遍地，在栈中分配大块的内存是一个坏的主意。因为这很容易用光你的栈空间，尤其是在内存受限的系统或者支持大量小堆栈的线程的系统上，因为Memcheck执行的错误检查，对于堆上的数据比对栈上的数据要高效很多。如果你使用这个选项，你可能希望考虑重写代码在堆上分配内存而不是在栈上分配。</p>
<h2 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h2><p>下面通过介绍几个范例来说明如何使用Memcheck （其他工具暂不涉及，感兴趣可以交流），示例仅供参考，更多用途可在实际应用中不断探索。</p>
<h3 id="1-数组越界-内存未释放"><a href="#1-数组越界-内存未释放" class="headerlink" title="1. 数组越界/内存未释放"></a>1. 数组越界/内存未释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = <span class="built_in">malloc</span>(<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    x[<span class="number">9</span>] = <span class="number">0</span>; <span class="comment">//数组下标越界</span></span><br><span class="line">&#125; <span class="comment">//内存未释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1）编译程序test-c"><a href="#1）编译程序test-c" class="headerlink" title="1）编译程序test.c"></a>1）编译程序test.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall test.c -g -o <span class="built_in">test</span> <span class="comment">#Wall提示所有告警，-g gdb，-o输出</span></span><br></pre></td></tr></table></figure>
<h4 id="2）使用Valgrind检查程序BUG"><a href="#2）使用Valgrind检查程序BUG" class="headerlink" title="2）使用Valgrind检查程序BUG"></a>2）使用Valgrind检查程序BUG</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full ./<span class="built_in">test</span></span><br><span class="line"><span class="comment">#--leak-check=full 所有泄露检查</span></span><br></pre></td></tr></table></figure>
<h4 id="3-运行结果如下："><a href="#3-运行结果如下：" class="headerlink" title="3) 运行结果如下："></a>3) 运行结果如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">==2989== Memcheck, a memory error detector</span><br><span class="line">==2989== Copyright (C) 2002-2012, and GNU GPL<span class="string">'d, by Julian Seward</span></span><br><span class="line"><span class="string">et al.</span></span><br><span class="line"><span class="string">==2989== Using Valgrind-3.8.1 and LibVEX; rerun with -h for</span></span><br><span class="line"><span class="string">copyright info</span></span><br><span class="line"><span class="string">==2989== Command: ./test</span></span><br><span class="line"><span class="string">==2989==</span></span><br><span class="line"><span class="string">==2989== Invalid write of size 4</span></span><br><span class="line"><span class="string">==2989== at 0x4004E2: k (test.c:5)</span></span><br><span class="line"><span class="string">==2989== by 0x4004F2: main (test.c:10)</span></span><br><span class="line"><span class="string">==2989== Address 0x4c27064 is 4 bytes after a block of size 32 alloc'</span>d</span><br><span class="line">==2989== at 0x4A06A2E: malloc (vg_replace_malloc.c:270)</span><br><span class="line">==2989== by 0x4004D5: k (test.c:4)</span><br><span class="line">==2989== by 0x4004F2: main (test.c:10)</span><br><span class="line">==2989==</span><br><span class="line">==2989==</span><br><span class="line">==2989== HEAP SUMMARY:</span><br><span class="line">==2989== <span class="keyword">in</span> use at <span class="built_in">exit</span>: 32 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==2989== total heap usage: 1 allocs, 0 frees, 32 bytes allocated</span><br><span class="line">==2989==</span><br><span class="line">==2989== 32 bytes <span class="keyword">in</span> 1 blocks are definitely lost <span class="keyword">in</span> loss record 1</span><br><span class="line">of 1</span><br><span class="line">==2989== at 0x4A06A2E: malloc (vg_replace_malloc.c:270)</span><br><span class="line">==2989== by 0x4004D5: k (test.c:4)</span><br><span class="line">==2989== by 0x4004F2: main (test.c:10)</span><br><span class="line">==2989==</span><br><span class="line">==2989== LEAK SUMMARY:</span><br><span class="line">==2989== definitely lost: 32 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==2989== indirectly lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==2989== possibly lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==2989== still reachable: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==2989==suppressed: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==2989==</span><br><span class="line">==2989== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==2989== ERROR SUMMARY: 2 errors from 2 contexts</span><br><span class="line">(suppressed: 6 from 6)</span><br></pre></td></tr></table></figure>
<h3 id="2-内存释放后读写"><a href="#2-内存释放后读写" class="headerlink" title="2.内存释放后读写"></a>2.内存释放后读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>); <span class="comment">//分配</span></span><br><span class="line">    *p = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = *p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n [%c]\n"</span>,c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放</span></span><br><span class="line">    c = *p; <span class="comment">//取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1）编译程序t2-c"><a href="#1）编译程序t2-c" class="headerlink" title="1）编译程序t2.c"></a>1）编译程序t2.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall t2.c -g -o t2</span><br></pre></td></tr></table></figure>
<h4 id="2）使用Valgrind检查程序BUG-1"><a href="#2）使用Valgrind检查程序BUG-1" class="headerlink" title="2）使用Valgrind检查程序BUG"></a>2）使用Valgrind检查程序BUG</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full ./t2</span><br></pre></td></tr></table></figure>
<h4 id="3-运行结果如下：-1"><a href="#3-运行结果如下：-1" class="headerlink" title="3) 运行结果如下："></a>3) 运行结果如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">==3058== Memcheck, a memory error detector</span><br><span class="line">==3058== Copyright (C) 2002-2012, and GNU GPL<span class="string">'d, by Julian</span></span><br><span class="line"><span class="string">Seward et al.</span></span><br><span class="line"><span class="string">==3058== Using Valgrind-3.8.1 and LibVEX; rerun with -h</span></span><br><span class="line"><span class="string">for copyright info</span></span><br><span class="line"><span class="string">==3058== Command: ./t2</span></span><br><span class="line"><span class="string">==3058==</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[a]</span></span><br><span class="line"><span class="string">==3058== Invalid read of size 1</span></span><br><span class="line"><span class="string">==3058== at 0x4005A3: main (t2.c:14)</span></span><br><span class="line"><span class="string">==3058== Address 0x4c27040 is 0 bytes inside a block of size</span></span><br><span class="line"><span class="string">1 free'</span>d</span><br><span class="line">==3058== at 0x4A06430: free (vg_replace_malloc.c:446)</span><br><span class="line">==3058== by 0x40059E: main (t2.c:13)</span><br><span class="line">==3058==</span><br><span class="line">==3058==</span><br><span class="line">==3058== HEAP SUMMARY:</span><br><span class="line">==3058== <span class="keyword">in</span> use at <span class="built_in">exit</span>: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==3058== total heap usage: 1 allocs, 1 frees, 1 bytes allocated</span><br><span class="line">==3058==</span><br><span class="line">==3058== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==3058==</span><br><span class="line">==3058== For counts of detected and suppressed errors, rerun with:</span><br><span class="line">-v</span><br><span class="line">==3058== ERROR SUMMARY: 1 errors from 1 contexts</span><br><span class="line">(suppressed: 6 from 6)</span><br></pre></td></tr></table></figure>
<p>从上输出内容可以看到，Valgrind检测到无效的读取操作然后输出“Invalid read of size 1”。</p>
<h3 id="3-无效读写"><a href="#3-无效读写" class="headerlink" title="3.无效读写"></a>3.无效读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>); <span class="comment">//分配1字节</span></span><br><span class="line">    *p = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">char</span> c = *(p+<span class="number">1</span>); <span class="comment">//地址加1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n [%c]\n"</span>,c); </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1）编译程序t3-c"><a href="#1）编译程序t3-c" class="headerlink" title="1）编译程序t3.c"></a>1）编译程序t3.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall t3.c -g -o t3</span><br></pre></td></tr></table></figure>
<h4 id="2）使用Valgrind检查程序BUG-2"><a href="#2）使用Valgrind检查程序BUG-2" class="headerlink" title="2）使用Valgrind检查程序BUG"></a>2）使用Valgrind检查程序BUG</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full ./t3</span><br></pre></td></tr></table></figure>
<h4 id="3-运行结果如下：-2"><a href="#3-运行结果如下：-2" class="headerlink" title="3) 运行结果如下："></a>3) 运行结果如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">==3128== Memcheck, a memory error detector</span><br><span class="line">==3128== Copyright (C) 2002-2012, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==3128== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==3128== Command: ./t3</span></span><br><span class="line"><span class="string">==3128==</span></span><br><span class="line"><span class="string">==3128== Invalid read of size 1 #无效读取</span></span><br><span class="line"><span class="string">==3128==at 0x400579: main (t3.c:9)</span></span><br><span class="line"><span class="string">==3128==Address 0x4c27041 is 0 bytes after a block of size 1 alloc'</span>d</span><br><span class="line">==3128==at 0x4A06A2E: malloc (vg_replace_malloc.c:270)</span><br><span class="line">==3128==by 0x400565: main (t3.c:6)</span><br><span class="line">==3128==</span><br><span class="line">[]</span><br><span class="line">==3128==</span><br><span class="line">==3128== HEAP SUMMARY:</span><br><span class="line">==3128==<span class="keyword">in</span> use at <span class="built_in">exit</span>: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==3128==total heap usage: 1 allocs, 1 frees, 1 bytes allocated</span><br><span class="line">==3128==</span><br><span class="line">==3128== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==3128==</span><br><span class="line">==3128== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==3128== ERROR SUMMARY: 1 errors from 1 contexts</span><br><span class="line">(suppressed: 6 from 6)</span><br></pre></td></tr></table></figure>
<h3 id="4-内存泄露"><a href="#4-内存泄露" class="headerlink" title="4.内存泄露"></a>4.内存泄露</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    *p = <span class="string">'x'</span>;</span><br><span class="line">    <span class="keyword">char</span> c = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,c); <span class="comment">//申请后未释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1）编译程序t4-c"><a href="#1）编译程序t4-c" class="headerlink" title="1）编译程序t4.c"></a>1）编译程序t4.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall t4.c -g -o t4</span><br></pre></td></tr></table></figure>
<h4 id="2）使用Valgrind检查程序BUG-3"><a href="#2）使用Valgrind检查程序BUG-3" class="headerlink" title="2）使用Valgrind检查程序BUG"></a>2）使用Valgrind检查程序BUG</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full ./t4</span><br></pre></td></tr></table></figure>
<h4 id="3-运行结果如下：-3"><a href="#3-运行结果如下：-3" class="headerlink" title="3) 运行结果如下："></a>3) 运行结果如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">==3221== Memcheck, a memory error detector</span><br><span class="line">==3221== Copyright (C) 2002-2012, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==3221== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==3221== Command: ./t4</span></span><br><span class="line"><span class="string">==3221==</span></span><br><span class="line"><span class="string">==3221== Invalid write of size 4</span></span><br><span class="line"><span class="string">==3221==at 0x40051E: main (t4.c:7)</span></span><br><span class="line"><span class="string">==3221==Address 0x4c27040 is 0 bytes inside a block of size 1 alloc'</span>d</span><br><span class="line">==3221==at 0x4A06A2E: malloc (vg_replace_malloc.c:270)</span><br><span class="line">==3221==by 0x400515: main (t4.c:6)</span><br><span class="line">==3221==</span><br><span class="line">==3221== Invalid <span class="built_in">read</span> of size 4</span><br><span class="line">==3221==at 0x400528: main (t4.c:8)</span><br><span class="line">==3221==Address 0x4c27040 is 0 bytes inside a block of size 1 alloc<span class="string">'d</span></span><br><span class="line"><span class="string">==3221==at 0x4A06A2E: malloc (vg_replace_malloc.c:270)</span></span><br><span class="line"><span class="string">==3221==by 0x400515: main (t4.c:6)</span></span><br><span class="line"><span class="string">==3221==</span></span><br><span class="line"><span class="string">x</span></span><br><span class="line"><span class="string">==3221==</span></span><br><span class="line"><span class="string">==3221== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==3221==in use at exit: 1 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==3221==total heap usage: 1 allocs, 0 frees, 1 bytes allocated</span></span><br><span class="line"><span class="string">==3221==</span></span><br><span class="line"><span class="string">==3221== 1 bytes in 1 blocks are definitely lost in loss record 1 of 1</span></span><br><span class="line"><span class="string">==3221==at 0x4A06A2E: malloc (vg_replace_malloc.c:270)</span></span><br><span class="line"><span class="string">==3221==by 0x400515: main (t4.c:6)</span></span><br><span class="line"><span class="string">==3221==</span></span><br><span class="line"><span class="string">==3221== LEAK SUMMARY:</span></span><br><span class="line"><span class="string">==3221==definitely lost: 1 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==3221==indirectly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==3221== possibly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==3221==still reachable: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==3221== suppressed: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==3221==</span></span><br><span class="line"><span class="string">==3221== For counts of detected and suppressed errors, rerun with: -v</span></span><br><span class="line"><span class="string">==3221== ERROR SUMMARY: 3 errors from 3 contexts</span></span><br><span class="line"><span class="string">(suppressed: 6 from 6)</span></span><br></pre></td></tr></table></figure>
<p>从检查结果看，可以发现内存泄露。</p>
<h3 id="5-内存多次释放"><a href="#5-内存多次释放" class="headerlink" title="5.内存多次释放"></a>5.内存多次释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>); </span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Memory Allocated at: %s/n"</span>,p); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Enough Memory!/n"</span>); </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//重复释放</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1）编译程序t5-c"><a href="#1）编译程序t5-c" class="headerlink" title="1）编译程序t5.c"></a>1）编译程序t5.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall t5.c -g -o t5</span><br><span class="line">``` </span><br><span class="line"><span class="comment">#### 2）使用Valgrind检查程序BUG</span></span><br><span class="line">``` bash</span><br><span class="line">valgrind --tool=memcheck --leak-check=full ./t5</span><br></pre></td></tr></table></figure>
<h4 id="3-运行结果如下：-4"><a href="#3-运行结果如下：-4" class="headerlink" title="3) 运行结果如下："></a>3) 运行结果如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">==3294== Memcheck, a memory error detector</span><br><span class="line">==3294== Copyright (C) 2002-2012, and GNU GPL<span class="string">'d, by Julian Seward</span></span><br><span class="line"><span class="string">et al.</span></span><br><span class="line"><span class="string">==3294== Using Valgrind-3.8.1 and LibVEX; rerun with -h for</span></span><br><span class="line"><span class="string">copyright info</span></span><br><span class="line"><span class="string">==3294== Command: ./t5</span></span><br><span class="line"><span class="string">==3294==</span></span><br><span class="line"><span class="string">==3294== Conditional jump or move depends on uninitialised value(s)</span></span><br><span class="line"><span class="string">==3294== at 0x3CD4C47E2C: vfprintf (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==3294== by 0x3CD4C4F189: printf (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==3294== by 0x400589: main (t5.c:9)</span></span><br><span class="line"><span class="string">==3294==</span></span><br><span class="line"><span class="string">==3294== Invalid free() / delete / delete[] / realloc()</span></span><br><span class="line"><span class="string">==3294== at 0x4A06430: free (vg_replace_malloc.c:446)</span></span><br><span class="line"><span class="string">==3294== by 0x4005B5: main (t5.c:13)</span></span><br><span class="line"><span class="string">==3294== Address 0x4c27040 is 0 bytes inside a block of size</span></span><br><span class="line"><span class="string">100 free'</span>d</span><br><span class="line">==3294== at 0x4A06430: free (vg_replace_malloc.c:446)</span><br><span class="line">==3294== by 0x4005A9: main (t5.c:12)</span><br><span class="line">==3294==</span><br><span class="line">==3294== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==3294== at 0x4A06430: free (vg_replace_malloc.c:446)</span><br><span class="line">==3294== by 0x4005C1: main (t5.c:14)</span><br><span class="line">==3294== Address 0x4c27040 is 0 bytes inside a block of size</span><br><span class="line">100 free<span class="string">'d</span></span><br><span class="line"><span class="string">==3294== at 0x4A06430: free (vg_replace_malloc.c:446)</span></span><br><span class="line"><span class="string">==3294== by 0x4005A9: main (t5.c:12)</span></span><br><span class="line"><span class="string">==3294==</span></span><br><span class="line"><span class="string">Memory Allocated at: /n==3294==</span></span><br><span class="line"><span class="string">==3294== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==3294== in use at exit: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==3294== total heap usage: 1 allocs, 3 frees, 100 bytes allocated</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出可以看到(标注), 该功能检测到我们对同一个指针调用了3次释放内存操作。</p>
<h3 id="6-内存动态管理"><a href="#6-内存动态管理" class="headerlink" title="6.内存动态管理"></a>6.内存动态管理</h3><p>常见的内存分配方式分三种：静态存储，栈上分配，堆上分配。全局变量属于静态存储，它们是在编译时就被分配了存储空间，函数内的局部变量属于栈上分配，而最灵活的内存使用方式当属堆上分配，也叫做内存动态分配了。常用的内存动态分配函数包括：malloc, alloc, realloc, new等，动态释放函数包括free, delete。<br><br>一旦成功申请了动态内存，我们就需要自己对其进行内存管理，而这又是最容易犯错误的。下面的一段程序，就包括了内存动态管理中常见的错误。<br></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">char</span>* pt=p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    pt[<span class="number">1</span>] = <span class="string">'x'</span>;</span><br><span class="line">    <span class="built_in">free</span>(pt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1）编译程序t6-c"><a href="#1）编译程序t6-c" class="headerlink" title="1）编译程序t6.c"></a>1）编译程序t6.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall t6.c -g -o t6</span><br></pre></td></tr></table></figure>
<h4 id="2）使用Valgrind检查程序BUG-4"><a href="#2）使用Valgrind检查程序BUG-4" class="headerlink" title="2）使用Valgrind检查程序BUG"></a>2）使用Valgrind检查程序BUG</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full ./t6</span><br></pre></td></tr></table></figure>
<h4 id="3-运行结果如下：-5"><a href="#3-运行结果如下：-5" class="headerlink" title="3) 运行结果如下："></a>3) 运行结果如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">==3380== Memcheck, a memory error detector</span><br><span class="line">==3380== Copyright (C) 2002-2012, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==3380== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==3380== Command: ./t6</span></span><br><span class="line"><span class="string">==3380==</span></span><br><span class="line"><span class="string">==3380== Invalid write of size 1</span></span><br><span class="line"><span class="string">==3380==at 0x40055C: main (t6.c:14)</span></span><br><span class="line"><span class="string">==3380==Address 0x4c27041 is 1 bytes inside a block of size 10 free'</span>d</span><br><span class="line">==3380==at 0x4A06430: free (vg_replace_malloc.c:446)</span><br><span class="line">==3380==by 0x400553: main (t6.c:13)</span><br><span class="line">==3380==</span><br><span class="line">==3380== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==3380==at 0x4A06430: free (vg_replace_malloc.c:446)</span><br><span class="line">==3380==by 0x40056A: main (t6.c:15)</span><br><span class="line">==3380==Address 0x4c27040 is 0 bytes inside a block of size 10 free<span class="string">'d</span></span><br><span class="line"><span class="string">==3380==at 0x4A06430: free (vg_replace_malloc.c:446)</span></span><br><span class="line"><span class="string">==3380==by 0x400553: main (t6.c:13)</span></span><br><span class="line"><span class="string">==3380==</span></span><br><span class="line"><span class="string">==3380==</span></span><br><span class="line"><span class="string">==3380== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==3380==in use at exit: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==3380==total heap usage: 1 allocs, 2 frees, 10 bytes allocated</span></span><br></pre></td></tr></table></figure>
<p>申请内存在使用完成后就要释放。如果没有释放，或少释放了就是内存泄露；多释放也会产生问题。上述程序中，指针p和pt指向的是同一块内存，却被先后释放两次。系统会在堆上维护一个动态内存链表，如果被释放，就意味着该块内存可以继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种严重的错误，上述程序第14行中就在释放后仍然写这块内存。<br><br>输出结果显示，第13行分配和释放函数不一致；第14行发生非法写操作，也就是往释放后的内存地址写值；第15行释放内存函数无效。<br></p>
<h2 id="生成可视化的图形"><a href="#生成可视化的图形" class="headerlink" title="生成可视化的图形"></a>生成可视化的图形</h2><p>生成可视化的图形需要下载gprof2dot：<a href="https://pypi.org/project/gprof2dot/#files" target="_blank" rel="noopener">https://pypi.org/project/gprof2dot/#files</a><br><br>这是个Python脚本，把它下载之后修改其权限<code>chmod +7 gprof2dot.py</code>，并把这个脚本添加到$PATH路径中的任一文件夹下，我是将它放到了/usr/bin目录下，这样就可以直接在终端下执行gprof2dot.py了。<br><br>首先执行<code>gcc -pg -o tmp tmp.c</code>，然后运行该程序<code>./tmp</code>，程序运行完成后会在当前目录下生成gmon.out文件（这个文件gprof在分析程序时需要），再执行<code>gprof ./tmp | gprof2dot.py |dot -Tpng -o report.png</code>，打开report.png结果：<br></p>
<p>再来看 Callgrind的生成调用图过程吧，执行：<code>valgrind --tool=callgrind ./tmp</code>，执行完成后在目录下生成”callgrind.out.XXX”的文件这是分析文件，可以直接利用：callgrind_annotate callgrind.out.XXX 打印结果，也可以使用：<code>gprof2dot.py -f callgrind callgrind.out.XXX |dot -Tpng -o report.png</code> 来生成图形化结果:</p>
<p>它生成的结果非常详细，甚至连函数入口，及库函数调用都标识出来了。<br><br>原文链接：<a href="https://blog.csdn.net/andylauren/java/article/details/93189740" target="_blank" rel="noopener">https://blog.csdn.net/andylauren/java/article/details/93189740</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2018/02/06/ipv6%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90/" rel="next" title="ipv6地址生成方式">
      ipv6地址生成方式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#valgrind介绍"><span class="nav-number">1.</span> <span class="nav-text">valgrind介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工具"><span class="nav-number">2.</span> <span class="nav-text">工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Memcheck"><span class="nav-number">2.1.</span> <span class="nav-text">1. Memcheck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Callgrind"><span class="nav-number">2.2.</span> <span class="nav-text">2. Callgrind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Cachegrind"><span class="nav-number">2.3.</span> <span class="nav-text">3. Cachegrind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Helgrind"><span class="nav-number">2.4.</span> <span class="nav-text">4. Helgrind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Massif"><span class="nav-number">2.5.</span> <span class="nav-text">5. Massif</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-number">3.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检测原理："><span class="nav-number">3.0.1.</span> <span class="nav-text">检测原理：
</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">4.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">5.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-检查内存错误："><span class="nav-number">5.1.</span> <span class="nav-text">1. 检查内存错误：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-检查代码覆盖和性能瓶颈："><span class="nav-number">5.2.</span> <span class="nav-text">2. 检查代码覆盖和性能瓶颈：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用法"><span class="nav-number">6.</span> <span class="nav-text">用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概要用法："><span class="nav-number">6.1.</span> <span class="nav-text">概要用法：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">7.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number">8.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用实践"><span class="nav-number">9.</span> <span class="nav-text">应用实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数组越界-内存未释放"><span class="nav-number">9.1.</span> <span class="nav-text">1. 数组越界&#x2F;内存未释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）编译程序test-c"><span class="nav-number">9.1.1.</span> <span class="nav-text">1）编译程序test.c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）使用Valgrind检查程序BUG"><span class="nav-number">9.1.2.</span> <span class="nav-text">2）使用Valgrind检查程序BUG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运行结果如下："><span class="nav-number">9.1.3.</span> <span class="nav-text">3) 运行结果如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内存释放后读写"><span class="nav-number">9.2.</span> <span class="nav-text">2.内存释放后读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）编译程序t2-c"><span class="nav-number">9.2.1.</span> <span class="nav-text">1）编译程序t2.c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）使用Valgrind检查程序BUG-1"><span class="nav-number">9.2.2.</span> <span class="nav-text">2）使用Valgrind检查程序BUG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运行结果如下：-1"><span class="nav-number">9.2.3.</span> <span class="nav-text">3) 运行结果如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-无效读写"><span class="nav-number">9.3.</span> <span class="nav-text">3.无效读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）编译程序t3-c"><span class="nav-number">9.3.1.</span> <span class="nav-text">1）编译程序t3.c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）使用Valgrind检查程序BUG-2"><span class="nav-number">9.3.2.</span> <span class="nav-text">2）使用Valgrind检查程序BUG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运行结果如下：-2"><span class="nav-number">9.3.3.</span> <span class="nav-text">3) 运行结果如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-内存泄露"><span class="nav-number">9.4.</span> <span class="nav-text">4.内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）编译程序t4-c"><span class="nav-number">9.4.1.</span> <span class="nav-text">1）编译程序t4.c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）使用Valgrind检查程序BUG-3"><span class="nav-number">9.4.2.</span> <span class="nav-text">2）使用Valgrind检查程序BUG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运行结果如下：-3"><span class="nav-number">9.4.3.</span> <span class="nav-text">3) 运行结果如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-内存多次释放"><span class="nav-number">9.5.</span> <span class="nav-text">5.内存多次释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）编译程序t5-c"><span class="nav-number">9.5.1.</span> <span class="nav-text">1）编译程序t5.c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运行结果如下：-4"><span class="nav-number">9.5.2.</span> <span class="nav-text">3) 运行结果如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-内存动态管理"><span class="nav-number">9.6.</span> <span class="nav-text">6.内存动态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）编译程序t6-c"><span class="nav-number">9.6.1.</span> <span class="nav-text">1）编译程序t6.c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）使用Valgrind检查程序BUG-4"><span class="nav-number">9.6.2.</span> <span class="nav-text">2）使用Valgrind检查程序BUG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运行结果如下：-5"><span class="nav-number">9.6.3.</span> <span class="nav-text">3) 运行结果如下：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成可视化的图形"><span class="nav-number">10.</span> <span class="nav-text">生成可视化的图形</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ysshen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ysshen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
